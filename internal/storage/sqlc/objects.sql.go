// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: objects.sql

package db

import (
	"context"
)

const checkObjectExistsOnBackend = `-- name: CheckObjectExistsOnBackend :one
SELECT EXISTS(
    SELECT 1 FROM object_locations
    WHERE object_key = $1 AND backend_name = $2
) AS exists
`

type CheckObjectExistsOnBackendParams struct {
	ObjectKey   string
	BackendName string
}

func (q *Queries) CheckObjectExistsOnBackend(ctx context.Context, arg CheckObjectExistsOnBackendParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkObjectExistsOnBackend, arg.ObjectKey, arg.BackendName)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const deleteObjectCopies = `-- name: DeleteObjectCopies :exec
DELETE FROM object_locations
WHERE object_key = $1
`

func (q *Queries) DeleteObjectCopies(ctx context.Context, objectKey string) error {
	_, err := q.db.Exec(ctx, deleteObjectCopies, objectKey)
	return err
}

const deleteObjectFromBackend = `-- name: DeleteObjectFromBackend :exec
DELETE FROM object_locations
WHERE object_key = $1 AND backend_name = $2
`

type DeleteObjectFromBackendParams struct {
	ObjectKey   string
	BackendName string
}

func (q *Queries) DeleteObjectFromBackend(ctx context.Context, arg DeleteObjectFromBackendParams) error {
	_, err := q.db.Exec(ctx, deleteObjectFromBackend, arg.ObjectKey, arg.BackendName)
	return err
}

const getAllObjectLocations = `-- name: GetAllObjectLocations :many
SELECT object_key, backend_name, size_bytes, created_at
FROM object_locations
WHERE object_key = $1
ORDER BY created_at ASC
`

func (q *Queries) GetAllObjectLocations(ctx context.Context, objectKey string) ([]ObjectLocation, error) {
	rows, err := q.db.Query(ctx, getAllObjectLocations, objectKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ObjectLocation{}
	for rows.Next() {
		var i ObjectLocation
		if err := rows.Scan(
			&i.ObjectKey,
			&i.BackendName,
			&i.SizeBytes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExistingCopiesForUpdate = `-- name: GetExistingCopiesForUpdate :many
SELECT backend_name, size_bytes
FROM object_locations
WHERE object_key = $1
FOR UPDATE
`

type GetExistingCopiesForUpdateRow struct {
	BackendName string
	SizeBytes   int64
}

func (q *Queries) GetExistingCopiesForUpdate(ctx context.Context, objectKey string) ([]GetExistingCopiesForUpdateRow, error) {
	rows, err := q.db.Query(ctx, getExistingCopiesForUpdate, objectKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetExistingCopiesForUpdateRow{}
	for rows.Next() {
		var i GetExistingCopiesForUpdateRow
		if err := rows.Scan(&i.BackendName, &i.SizeBytes); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertObjectLocation = `-- name: InsertObjectLocation :exec
INSERT INTO object_locations (object_key, backend_name, size_bytes, created_at)
VALUES ($1, $2, $3, NOW())
`

type InsertObjectLocationParams struct {
	ObjectKey   string
	BackendName string
	SizeBytes   int64
}

func (q *Queries) InsertObjectLocation(ctx context.Context, arg InsertObjectLocationParams) error {
	_, err := q.db.Exec(ctx, insertObjectLocation, arg.ObjectKey, arg.BackendName, arg.SizeBytes)
	return err
}

const insertObjectLocationIfNotExists = `-- name: InsertObjectLocationIfNotExists :one
INSERT INTO object_locations (object_key, backend_name, size_bytes, created_at)
VALUES ($1, $2, $3, NOW())
ON CONFLICT (object_key, backend_name) DO NOTHING
RETURNING true AS inserted
`

type InsertObjectLocationIfNotExistsParams struct {
	ObjectKey   string
	BackendName string
	SizeBytes   int64
}

func (q *Queries) InsertObjectLocationIfNotExists(ctx context.Context, arg InsertObjectLocationIfNotExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, insertObjectLocationIfNotExists, arg.ObjectKey, arg.BackendName, arg.SizeBytes)
	var inserted bool
	err := row.Scan(&inserted)
	return inserted, err
}

const listObjectsByBackend = `-- name: ListObjectsByBackend :many
SELECT object_key, backend_name, size_bytes, created_at
FROM object_locations
WHERE backend_name = $1
ORDER BY size_bytes ASC
LIMIT $2
`

type ListObjectsByBackendParams struct {
	BackendName string
	Limit       int32
}

func (q *Queries) ListObjectsByBackend(ctx context.Context, arg ListObjectsByBackendParams) ([]ObjectLocation, error) {
	rows, err := q.db.Query(ctx, listObjectsByBackend, arg.BackendName, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ObjectLocation{}
	for rows.Next() {
		var i ObjectLocation
		if err := rows.Scan(
			&i.ObjectKey,
			&i.BackendName,
			&i.SizeBytes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listObjectsByPrefix = `-- name: ListObjectsByPrefix :many
SELECT DISTINCT ON (object_key) object_key, backend_name, size_bytes, created_at
FROM object_locations
WHERE object_key LIKE $1::text || '%' ESCAPE '\'
  AND object_key > $2
ORDER BY object_key, created_at ASC
LIMIT $3
`

type ListObjectsByPrefixParams struct {
	Prefix     string
	StartAfter string
	MaxKeys    int32
}

func (q *Queries) ListObjectsByPrefix(ctx context.Context, arg ListObjectsByPrefixParams) ([]ObjectLocation, error) {
	rows, err := q.db.Query(ctx, listObjectsByPrefix, arg.Prefix, arg.StartAfter, arg.MaxKeys)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ObjectLocation{}
	for rows.Next() {
		var i ObjectLocation
		if err := rows.Scan(
			&i.ObjectKey,
			&i.BackendName,
			&i.SizeBytes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const lockObjectOnBackend = `-- name: LockObjectOnBackend :one
SELECT size_bytes
FROM object_locations
WHERE object_key = $1 AND backend_name = $2
FOR UPDATE
`

type LockObjectOnBackendParams struct {
	ObjectKey   string
	BackendName string
}

func (q *Queries) LockObjectOnBackend(ctx context.Context, arg LockObjectOnBackendParams) (int64, error) {
	row := q.db.QueryRow(ctx, lockObjectOnBackend, arg.ObjectKey, arg.BackendName)
	var size_bytes int64
	err := row.Scan(&size_bytes)
	return size_bytes, err
}
