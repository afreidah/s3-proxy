// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: usage.sql

package db

import (
	"context"
)

const flushUsageDeltas = `-- name: FlushUsageDeltas :exec
INSERT INTO backend_usage (backend_name, period, api_requests, egress_bytes, ingress_bytes, updated_at)
VALUES ($1, $2, $3, $4, $5, NOW())
ON CONFLICT (backend_name, period) DO UPDATE SET
    api_requests  = backend_usage.api_requests  + $3,
    egress_bytes  = backend_usage.egress_bytes  + $4,
    ingress_bytes = backend_usage.ingress_bytes + $5,
    updated_at    = NOW()
`

type FlushUsageDeltasParams struct {
	BackendName  string
	Period       string
	ApiRequests  int64
	EgressBytes  int64
	IngressBytes int64
}

// Atomically adds accumulated in-memory deltas to the persistent usage row.
// Creates the row if it doesn't exist for this (backend, period) yet.
func (q *Queries) FlushUsageDeltas(ctx context.Context, arg FlushUsageDeltasParams) error {
	_, err := q.db.Exec(ctx, flushUsageDeltas,
		arg.BackendName,
		arg.Period,
		arg.ApiRequests,
		arg.EgressBytes,
		arg.IngressBytes,
	)
	return err
}

const getUsageForPeriod = `-- name: GetUsageForPeriod :many
SELECT backend_name, api_requests, egress_bytes, ingress_bytes
FROM backend_usage
WHERE period = $1
`

type GetUsageForPeriodRow struct {
	BackendName  string
	ApiRequests  int64
	EgressBytes  int64
	IngressBytes int64
}

// Returns usage stats for all backends in the given period (e.g. '2026-02').
func (q *Queries) GetUsageForPeriod(ctx context.Context, period string) ([]GetUsageForPeriodRow, error) {
	rows, err := q.db.Query(ctx, getUsageForPeriod, period)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUsageForPeriodRow{}
	for rows.Next() {
		var i GetUsageForPeriodRow
		if err := rows.Scan(
			&i.BackendName,
			&i.ApiRequests,
			&i.EgressBytes,
			&i.IngressBytes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
