// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: multipart.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createMultipartUpload = `-- name: CreateMultipartUpload :exec
INSERT INTO multipart_uploads (upload_id, object_key, backend_name, content_type, created_at)
VALUES ($1, $2, $3, $4, NOW())
`

type CreateMultipartUploadParams struct {
	UploadID    string
	ObjectKey   string
	BackendName string
	ContentType *string
}

func (q *Queries) CreateMultipartUpload(ctx context.Context, arg CreateMultipartUploadParams) error {
	_, err := q.db.Exec(ctx, createMultipartUpload,
		arg.UploadID,
		arg.ObjectKey,
		arg.BackendName,
		arg.ContentType,
	)
	return err
}

const deleteMultipartUpload = `-- name: DeleteMultipartUpload :exec
DELETE FROM multipart_uploads
WHERE upload_id = $1
`

func (q *Queries) DeleteMultipartUpload(ctx context.Context, uploadID string) error {
	_, err := q.db.Exec(ctx, deleteMultipartUpload, uploadID)
	return err
}

const getMultipartUpload = `-- name: GetMultipartUpload :one
SELECT upload_id, object_key, backend_name, content_type, created_at
FROM multipart_uploads
WHERE upload_id = $1
`

func (q *Queries) GetMultipartUpload(ctx context.Context, uploadID string) (MultipartUpload, error) {
	row := q.db.QueryRow(ctx, getMultipartUpload, uploadID)
	var i MultipartUpload
	err := row.Scan(
		&i.UploadID,
		&i.ObjectKey,
		&i.BackendName,
		&i.ContentType,
		&i.CreatedAt,
	)
	return i, err
}

const getParts = `-- name: GetParts :many
SELECT part_number, etag, size_bytes, created_at
FROM multipart_parts
WHERE upload_id = $1
ORDER BY part_number
`

type GetPartsRow struct {
	PartNumber int32
	Etag       string
	SizeBytes  int64
	CreatedAt  pgtype.Timestamptz
}

func (q *Queries) GetParts(ctx context.Context, uploadID string) ([]GetPartsRow, error) {
	rows, err := q.db.Query(ctx, getParts, uploadID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPartsRow{}
	for rows.Next() {
		var i GetPartsRow
		if err := rows.Scan(
			&i.PartNumber,
			&i.Etag,
			&i.SizeBytes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStaleMultipartUploads = `-- name: GetStaleMultipartUploads :many
SELECT upload_id, object_key, backend_name, content_type, created_at
FROM multipart_uploads
WHERE created_at < $1
`

func (q *Queries) GetStaleMultipartUploads(ctx context.Context, createdAt pgtype.Timestamptz) ([]MultipartUpload, error) {
	rows, err := q.db.Query(ctx, getStaleMultipartUploads, createdAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MultipartUpload{}
	for rows.Next() {
		var i MultipartUpload
		if err := rows.Scan(
			&i.UploadID,
			&i.ObjectKey,
			&i.BackendName,
			&i.ContentType,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertPart = `-- name: UpsertPart :exec
INSERT INTO multipart_parts (upload_id, part_number, etag, size_bytes, created_at)
VALUES ($1, $2, $3, $4, NOW())
ON CONFLICT (upload_id, part_number) DO UPDATE SET
    etag = $3, size_bytes = $4, created_at = NOW()
`

type UpsertPartParams struct {
	UploadID   string
	PartNumber int32
	Etag       string
	SizeBytes  int64
}

func (q *Queries) UpsertPart(ctx context.Context, arg UpsertPartParams) error {
	_, err := q.db.Exec(ctx, upsertPart,
		arg.UploadID,
		arg.PartNumber,
		arg.Etag,
		arg.SizeBytes,
	)
	return err
}
