// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: quota.sql

package db

import (
	"context"
)

const decrementQuota = `-- name: DecrementQuota :exec
UPDATE backend_quotas
SET bytes_used = GREATEST(0, bytes_used - $1), updated_at = NOW()
WHERE backend_name = $2
`

type DecrementQuotaParams struct {
	Amount      int64
	BackendName string
}

func (q *Queries) DecrementQuota(ctx context.Context, arg DecrementQuotaParams) error {
	_, err := q.db.Exec(ctx, decrementQuota, arg.Amount, arg.BackendName)
	return err
}

const getActiveMultipartCountsByBackend = `-- name: GetActiveMultipartCountsByBackend :many
SELECT backend_name, COUNT(*) AS upload_count
FROM multipart_uploads
GROUP BY backend_name
`

type GetActiveMultipartCountsByBackendRow struct {
	BackendName string
	UploadCount int64
}

func (q *Queries) GetActiveMultipartCountsByBackend(ctx context.Context) ([]GetActiveMultipartCountsByBackendRow, error) {
	rows, err := q.db.Query(ctx, getActiveMultipartCountsByBackend)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetActiveMultipartCountsByBackendRow{}
	for rows.Next() {
		var i GetActiveMultipartCountsByBackendRow
		if err := rows.Scan(&i.BackendName, &i.UploadCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllQuotaStats = `-- name: GetAllQuotaStats :many
SELECT backend_name, bytes_used, bytes_limit, updated_at
FROM backend_quotas
`

func (q *Queries) GetAllQuotaStats(ctx context.Context) ([]BackendQuota, error) {
	rows, err := q.db.Query(ctx, getAllQuotaStats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []BackendQuota{}
	for rows.Next() {
		var i BackendQuota
		if err := rows.Scan(
			&i.BackendName,
			&i.BytesUsed,
			&i.BytesLimit,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBackendAvailableSpace = `-- name: GetBackendAvailableSpace :one
SELECT (q.bytes_limit - q.bytes_used - COALESCE(m.inflight, 0))::bigint AS available
FROM backend_quotas q
LEFT JOIN (
    SELECT mu.backend_name, SUM(mp.size_bytes) AS inflight
    FROM multipart_uploads mu
    JOIN multipart_parts mp ON mp.upload_id = mu.upload_id
    GROUP BY mu.backend_name
) m ON m.backend_name = q.backend_name
WHERE q.backend_name = $1
`

func (q *Queries) GetBackendAvailableSpace(ctx context.Context, backendName string) (int64, error) {
	row := q.db.QueryRow(ctx, getBackendAvailableSpace, backendName)
	var available int64
	err := row.Scan(&available)
	return available, err
}

const getObjectCountsByBackend = `-- name: GetObjectCountsByBackend :many
SELECT backend_name, COUNT(*) AS object_count
FROM object_locations
GROUP BY backend_name
`

type GetObjectCountsByBackendRow struct {
	BackendName string
	ObjectCount int64
}

func (q *Queries) GetObjectCountsByBackend(ctx context.Context) ([]GetObjectCountsByBackendRow, error) {
	rows, err := q.db.Query(ctx, getObjectCountsByBackend)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetObjectCountsByBackendRow{}
	for rows.Next() {
		var i GetObjectCountsByBackendRow
		if err := rows.Scan(&i.BackendName, &i.ObjectCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementQuota = `-- name: IncrementQuota :exec
UPDATE backend_quotas
SET bytes_used = bytes_used + $1, updated_at = NOW()
WHERE backend_name = $2
`

type IncrementQuotaParams struct {
	Amount      int64
	BackendName string
}

func (q *Queries) IncrementQuota(ctx context.Context, arg IncrementQuotaParams) error {
	_, err := q.db.Exec(ctx, incrementQuota, arg.Amount, arg.BackendName)
	return err
}

const upsertQuotaLimit = `-- name: UpsertQuotaLimit :exec
INSERT INTO backend_quotas (backend_name, bytes_limit, bytes_used, updated_at)
VALUES ($1, $2, 0, NOW())
ON CONFLICT (backend_name) DO UPDATE SET
    bytes_limit = $2,
    updated_at = NOW()
`

type UpsertQuotaLimitParams struct {
	BackendName string
	BytesLimit  int64
}

func (q *Queries) UpsertQuotaLimit(ctx context.Context, arg UpsertQuotaLimitParams) error {
	_, err := q.db.Exec(ctx, upsertQuotaLimit, arg.BackendName, arg.BytesLimit)
	return err
}
